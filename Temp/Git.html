<html><head><style type="text/css" id="wiz_todo_style_id" wiz_link_version="01.00.08">.wiz-todo, .wiz-todo-img {width: 16px; height: 16px; cursor: default; padding: 0 10px 0 2px; vertical-align: -10%;-webkit-user-select: none;} .wiz-todo-label { display: inline-block; padding-top: 8px; padding-bottom: 8px; line-height: 1;} .wiz-todo-label-checked { /*text-decoration: line-through;*/ color: #666;} .wiz-todo-label-unchecked {text-decoration: initial;} .wiz-todo-completed-info {padding-left: 44px; display: inline-block; } .wiz-todo-avatar { width:20px; height: 20px; vertical-align: -20%; margin-right:10px; border-radius: 2px;} .wiz-todo-account, .wiz-todo-dt { color: #666; }</style></head><body><!--?xml version="1.0" encoding="UTF-8"?--><en-note style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><ul class=" list-paddingleft-2"><li><p>配置</p></li></ul><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;git config --global user.name &quot;用户名&quot;<br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;git config --global user.email 邮箱</p><ul class=" list-paddingleft-2"><li><p>创建版本库</p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>创建空目录</p></li></ul></ul><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mkdir 目录名</p></blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cd 目录名</p></blockquote><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pwd（pwd命令用于显示当前目录）</p><ul class=" list-paddingleft-2"><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>把目录变成可管理的仓库</p></li></ul></ul><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; git init（.git 用于跟踪管理版本库）</p><ul class=" list-paddingleft-2"><li><p>把文件添加到版本库</p></li></ul><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; git只跟踪文本文件的改动（含内容），可以管理二进制文件如图片视频word文档，但无法跟踪其内容变化（但可以知道大小变化）</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; git中要以纯文本方式编写文件 建议使用统一的UTF-8编码（减少冲突、支持所有平台）</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; windows忌用记事本，以Notepad++代替</p><ul class=" list-paddingleft-2"><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>将文件拖入目录/子目录</p></li><li><p>git add 文件名&nbsp;</p></li><li><p>git commit -m&quot;本次提交的说明&quot;（将文件添加到仓库）</p></li></ul></ul><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;（git commit执行成功后，会告知改动情况；commit可在多次add后一次性提交多个文件）</p><ul class=" list-paddingleft-2"><li><p>提交修改</p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>git add 文件名（然后可以用git status看看情况）</p></li><li><p>git commit -m&quot;&quot;（再用git status看看情况，显示working directory clean为好）</p></li><li><p>git status 可以查看仓库当前状态</p></li><li><p>git diff 文件名 查看修改的具体内容</p></li><li><p>提交修改和提交新文件的步骤一样，两步</p></li></ul><li><p>版本回退</p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>git log 查看提交日志（每个commit都有版本号）,可以确定回到过去的哪个版本</p></li><li><p>HEAD表示当前版本，HEAD^上一个，HEAD^^上上个，更多：head~100</p></li><li><p>回退：git reset --hard commit_id</p></li><li><p>查看文本文件内容：cat 文件名</p></li><li><p>撤销回退（去未来）：git reset --hard 版本号（前几位）</p></li><li><p>不记得版本号：git reflog 查看每一次命令（含版本号），可以确定去未来的哪个版本</p></li></ul><li><p>工作区和暂存区</p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>工作区：电脑里的目录</p></li><li><p>工作区中的隐藏目录.git 是Git的版本库，其中存有最重要的暂存区（称为stage/index），以及Git的第一个分支master和指向master的第一个指针HEAD</p></li></ul><li><p><img hash="701e02bf0b2d71ab51b7e2b6aa973d52" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;" type="image/jpeg" src="Git_files/0.jpg" /></p></li><li><p>git add 是把文件添加到暂存区，git commit 是把暂存区的所有内容提交到当前分支。</p></li><li><p>管理修改</p></li></ul><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 必须先add 再 commit；用git diff HEAD -- 文件名 可以查看工作区和版本库里最新版本的区别。</p><ul class=" list-paddingleft-2"><li><p>撤销修改</p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>以一台电脑充当服务器，每个人从服务器仓库克隆到本机，将各自的推送提交到服务器仓库，也从中拉取别人的提交；Github提供仓库代管服务</p></li><li><p>本地Git仓库和Github仓库之间的传输通过SSH加密，所以需要设置</p></li><li><p>在文件管理器中删除/rm 文件名</p></li><li><p>如果要在版本库中删除文件，再使用命令 git rm 并 git commit</p></li><li><p>如果错删，git checkoyut 回退到最新版本</p></li><li><p>只能回复文件到最新版本，会丢失最后一次提交后修改的内容</p></li><li><p>用git reset HEAD 文件名 撤销暂存区的修改，放回工作区</p></li><li><p>git reset 可以回退版本，也可以把暂存区的修改回退到工作区，当使用HEAD时，表示最新的版本</p></li><li><p>然后按照场景1操作</p></li><li><p>git checkout -- 文件名（必须有 -- 否则会创建一个新分支） 可以丢弃工作区的修改。有两种情况：</p></li><li><p>场景1：撤销工作区修改</p></li><li><p>场景2：修改的内容已经添加到暂存区，但没有提交</p></li><li><p>删除文件</p></li><li><p>远程仓库</p></li></ul><ol class=" list-paddingleft-2"><li><p>创建SSH key：在用户主目录下找到.ssh目录，查看是否有id_rsa 和 id_rsa.pub 文件，如有，到下一步；没有，ssh-keygen -t rsa -C &quot;邮箱&quot; 创建</p></li><li><p>id_rsa 是私钥不泄露；id_rsa.pub是公钥，可以告诉别人</p></li><li><p>在github的用户管理中SSH Keys页面，add SSH key，任意title，粘贴id_rsa.pub 中的内容</p></li><li><p>文件修改后还未放到暂存区，撤销后回到和版本库一样的状态</p></li><li><p>文件已经添加到暂存区后，又做了修改，撤销后回到添加到暂存区后的状态</p></li><li><p>即：让文件回到最后一次git commit 或 git add 后的状态</p></li></ol><li><p>添加远程库</p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>在Github创建新库 与本地库同名；可以从这个仓库克隆新库，也可以将已有的本地库与之关联</p></li><li><p>在本地库下运行 git remote add origin url</p></li><li><p>添加后远程库默认名origin</p></li><li><p>推送本地库到远程库：git push -u origin master</p></li><li><p>SSH警告</p></li></ul><ol class=" list-paddingleft-2"><li><p>git push实质上是把当前分支推送到远程</p></li><li><p>远程库是空的，所以第一次推送时加上-u参数（Git会将本地master内容推送到远程的新的master中，并将它们关联，以后就可以简化）</p></li><li><p>以后，在本地的提交可以用 git push origin master 推送到远程库</p></li><li><p>第一次使用Git的clone或push命令会出现警告，是SSH连接在第一次验证github服务器的key时确认github的key是否真的来自github服务器，输入yes即可</p></li></ol><li><p>从远程库克隆</p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>url可以使用ssh支持的原生git协议（最快），也可以使用https等其他协议</p></li><li><p>但是https速度较慢，且每次推送都必须输入口令</p></li><li><p>git clone url</p></li></ul><li><p>创建与合并分支</p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>git merge 用于合并指定分支到当前分支</p></li><li><p>提示中会出现Fast-forward，说明这次合并是快进模式，直接将master指向dev的当前提交</p></li><li><p>此时，在分支中修改过的文件，修改的内容会不见</p></li><li><p>因为master分支的提交点没有变</p></li><li><p>-b参数表示创建并切换 相当于1、2相加：</p></li><li><p>创建并切换到分支： git checkout -b 分支名</p></li><li><p>git branch 查看当前分支：会列出所有分支并在当前分支前加*号</p></li><li><p>在分支中修改添加提交后 用 git checkout master切换回master分支</p></li><li><p>将分支的内容合并到master分支：git merge 分支名</p></li><li><p>合并后删除分支：git branch -d 分支名</p></li></ul><ol class=" list-paddingleft-2"><li><p>git branch 分支名</p></li><li><p>git checkout 分支名</p></li></ol><li><p>解决冲突</p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>分支间存在冲突 git merge合并时会报错</p></li><li><p>手动解决冲突后，可以用git log --graph --pretty=oneline --abbrev-commit查看分支合并情况</p></li></ul><li><p>分支管理策略</p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>保持master分支的稳定。用它发布新版本而不在上面干活。</p></li><li><p>在dev分支干活，dev可以不稳定，发布新版本时合并到master</p></li><li><p>多人开发时，每个人有自己的分支，随时合并到dev，发布时合并到master</p></li><li><p>git merge --no-ff -m&quot;描述&quot; 分支名</p></li><li><p>因要创建新commit，所以加入-m参数</p></li><li><p>git log带参数查看分支历史，可以看到分支信息</p></li><li><p>合并分支时，git通常用Fast forward模式，但是这种模式下，删除分支后，会丢掉分支</p></li><li><p>如果禁用Fast forward，git会在merge时生成新的commit，就可以从分支历史上看出分支信息</p></li><li><p>分支策略</p></li></ul><li><p>Bug分支</p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>跳到需要修复bug的分支，从该分支创建新分支，修复bug，切换到该分支完成合并，删除bug分支</p></li><li><p>git stash list查看之前保存的工作现场</p></li><li><p>git stash appy可恢复，但stash内容不删除 要用git stash drop；也可以直接用git stash pop，恢复并删除</p></li><li><p>此时git stash list 没有stash内容</p></li><li><p>git中bug可以通过创建新的临时分支修复，修复后合并分支并将临时分支删除</p></li><li><p>正在进行而无法提交的分支 可以用git stash储藏</p></li><li><p>多次stash，恢复时先用git stash list查看，然后用git stash apply stash@{<span style="color: inherit; font-family: Monaco, Menlo, Consolas, &#39;Courier New&#39;, monospace; font-size: 12px; line-height: 20px; white-space: pre-wrap;">0</span>}恢复指定的stash</p></li></ul><li><p>Feature分支</p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>开发feature最好新建分支</p></li><li><p>如果要丢弃一个未合并的分支，以git branch -D 分支名 强行删除（会丢失修改）</p></li></ul><li><p>多人协作</p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>从远程哭克隆时，默认只能看到本地的master</p></li><li><p>要在其他分支如dev上开发，需要创建origin的dev分支到本地：git checkout -b dev origin/dev；然后才能在dev上继续修改、提交，并push到远程</p></li><li><p>多人同时对dev修改并推送提交，有冲突，就用git pull把最新的提交从origin/dev抓取下来，在本地合并，解决冲突后推送</p></li><li><p>不是所有本地分支都要推送到远程库</p></li><li><p>master作为主分支，需要同步；dev作为开发分支，需要同步</p></li><li><p>bug只用于本地修复bug，可以不同步</p></li><li><p>feature是否推送，取决于是否要共同开发</p></li><li><p>查看远程库，使用 git remote；详情 使用git remote -v （会显示可抓取和推送的origin地址）</p></li><li><p>从远程库克隆时，git会自动把本地的master和远程的master对应，远程库默认名origin</p></li><li><p>推送分支，就是把该分支的所有本地提交推送到远程库：git push origin 分支名</p></li><li><p>抓取分支</p></li></ul><ol class=" list-paddingleft-2"><li><p>git pull可能失败，提示no tracking information，原因是没有指定本地dev与远程origin/dev的链接</p></li><li><p>设置dev和origin/dev的链接：git branch --set-upstream dev origin/dev</p></li><li><p>git pull后有冲突，按解决冲突的方法手动解决后提交并push</p></li></ol><li><p>标签管理</p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>本地删除：git tag -d 标签名</p></li><li><p>推送标签到远程：git push origin 标签名</p></li><li><p>一次性推送所有本地标签：git push origin --tags</p></li><li><p>删除已推送到远程的标签，先从本地删除，然后从远程删除：git push origin :refs/tags/标签名；删除成功与否，可登陆github查看</p></li><li><p>切换到需要打标签的分支</p></li><li><p>git tag 标签名 打标签；git tag 查看所有标签</p></li><li><p>git show 标签名 查看标签信息</p></li><li><p>git show -s 标签名 -m&quot;描述&quot; commit id 可以用私钥签名标签</p></li><li><p>发布一个版本时，通常在版本库中打一个标签，以唯一确定打标签时刻的版本；标签是版本库的一个快照；实质上是指向某个commit的指针</p></li><li><p>创建标签</p></li><li><p>操作标签</p></li></ul><ol class=" list-paddingleft-2"><li><p>默认标签打在最新的commit上；给历史commit打标签，找到commit id即可</p></li><li><p>git log --pretty=oneline --abbrev-commit 查看历史提交的commit</p></li><li><p>给特定commit打标签：git tag 标签名 commit id</p></li><li><p>标签不按时间排序，按字母</p></li><li><p>创建带有说明的标签：git tag -a 标签名 -m&quot;描述&quot;</p></li><li><p>这样，git show 标签名 还可以看到说明信息</p></li><li><p>签名采用PGP，所以必须安装gpg（GnuPG）</p></li><li><p>如果没有找到gpg或gpg密钥对，就会报错；报错请参考GnuPG帮助文档配置Key</p></li><li><p>这样，用git show 标签，可以看到PGP前面信息</p></li><li><p>用PGP签名的标签是不可伪造的，因为可以验证PGP签名参与开源项目</p></li></ol><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>fork，将仓库克隆到自己的账号</p></li><li><p>从自己的账号clone到本地，才能推送修改；如果希望官网接受修改，可以发起pull request贡献代码</p></li></ul><li><p>自定义git</p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>git config --global alias.别名 原command名</p></li><li><p>git 下有 .gitignore，填入需要忽略的文件，git status就会忽略它们</p></li><li><p>Github准备了各种配置文件：https://github.com/github/gitignore</p></li><li><p>忽略文件的原则：</p></li><li><p>git config --global color.ui true 显示颜色，让命令输出更醒目</p></li><li><p>某些文件不能被提交，如保存了数据库密码的配置文件</p></li><li><p>配置别名</p></li></ul><ol class=" list-paddingleft-2"><li><p><br/></p></li><li><p><img hash="03d5b9de77faef4449016093530303e9" style="cursor: default;" type="image/png" src="Git_files/0.png" /></p></li></ol><ol class=" list-paddingleft-2"><li><p>如git config --global alias.st status可以以st代替status</p></li><li><p>撤销暂存区修改的命令是git reset HEAD 文件名，可以配置一个unstage别名</p></li><li><p>配置git last 代替 git log -1 显示最后一次提交信息</p></li><li><p>git config --global alias.lg &quot;log --color --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot; 则git lg效果如图：zuo&#39;yo</p></li></ol><ol class=" list-paddingleft-2"><li><p><br/></p></li></ol><ol class=" list-paddingleft-2"><li><p>系统自动生成的文件如缩略图</p></li><li><p>编译生成的中间文件、可执行文件</p></li><li><p>带有敏感信息的配置文件</p></li><li><p>例如 windows下python开发，需要忽略windows的垃圾文件如desktop.ini；需要忽略python编辑产生的.pyc .pyo dist等文件或目录</p></li><li><p>把.git ignore 提交到git 即可；检验标准是git status是否working directory clean</p></li><li><p>windows下直接在文本编辑器保存.gitignore，资源管理器不支持空文件名</p></li></ol><li><p>配置文件</p></li><li><p><br/></p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>配置git时， --global针对当前用户，如果没有，则对当前仓库作用</p></li><li><p>每个仓库的配置文件在.git/config 中；别名在[alias]行下，可以直接修改</p></li><li><p>当前用户的配置文件在用户主目录下的隐藏文件.git config 中</p></li></ul><li><p>官网指南地址：http://git-scm.com/</p></li></ul></en-note></body></html>